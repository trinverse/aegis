# Data Models Documentation - Aegis AI Emergency Management

## Overview

This document provides comprehensive documentation of all TypeScript interfaces, their relationships, and data flow patterns within the Aegis system.

## Core Data Models

### Entity Relationship Diagram

```mermaid
erDiagram
    IncidentDetails ||--o{ AnalysisResult : generates
    IncidentDetails ||--o{ ImpactForecast : produces
    IncidentDetails ||--o{ TrainingScenario : creates
    AnalysisResult ||--o{ TeamBriefing : informs
    AnalysisResult ||--|| OperationsHub : enables
    Chat ||--o{ ChatMessage : contains

    IncidentDetails {
        string incidentType
        string location
        string severity
        string description
    }

    AnalysisResult {
        string summary
        array recommendedActions
        array potentialRisks
        array resourceSuggestions
    }

    ImpactForecast {
        array shortTermImpacts
        array longTermImpacts
        array communityLifelines
    }

    TeamBriefing {
        string missionStatement
        array keyObjectives
        array knownRisks
        string commsPlan
    }

    TrainingScenario {
        string scenarioTitle
        array learningObjectives
        string initialBriefing
        array timelineInjects
    }

    ChatMessage {
        enum sender
        string text
    }
```

## Detailed Interface Specifications

### IncidentDetails Interface

```typescript
interface IncidentDetails {
    incidentType: string;
    location: string;
    severity: string;
    description: string;
}
```

#### Field Specifications

| Field | Type | Constraints | Description | Example |
|-------|------|------------|-------------|---------|
| `incidentType` | string | Enum values | Type of emergency incident | "Natural Disaster" |
| `location` | string | Required, non-empty | Geographic location or address | "Downtown Metro Area" |
| `severity` | string | Enum values | Incident severity level | "High" |
| `description` | string | Required, min 10 chars | Detailed incident description | "Wildfire spreading rapidly..." |

#### Enum Values

```typescript
// Incident Types
const incidentTypes = [
    'Natural Disaster',
    'Technological Accident',
    'Terrorism',
    'Public Health Emergency',
    'Other'
];

// Severity Levels
const severityLevels = [
    'Low',
    'Moderate',
    'High',
    'Severe',
    'Catastrophic'
];
```

### AnalysisResult Interface

```typescript
interface AnalysisResult {
    summary: string;
    recommendedActions: string[];
    potentialRisks: string[];
    resourceSuggestions: string[];
}
```

#### Field Specifications

| Field | Type | Description | Typical Length | Generated By |
|-------|------|-------------|----------------|--------------|
| `summary` | string | Concise incident overview | 50-200 chars | Gemini Pro |
| `recommendedActions` | string[] | Immediate action items | 3-5 items | Gemini Pro |
| `potentialRisks` | string[] | Secondary hazards | 2-4 items | Gemini Pro |
| `resourceSuggestions` | string[] | Required resources | 3-5 items | Gemini Pro |

### ImpactForecast Interface

```typescript
interface ImpactForecast {
    shortTermImpacts: string[];
    longTermImpacts: string[];
    communityLifelines: {
        lifeline: string;
        impact: string;
        mitigation: string;
    }[];
}
```

#### Nested Structure

```mermaid
graph TD
    IF[ImpactForecast] --> STI[shortTermImpacts<br/>0-12 hours]
    IF --> LTI[longTermImpacts<br/>12-72 hours]
    IF --> CL[communityLifelines]

    CL --> CL1[Lifeline Object 1]
    CL --> CL2[Lifeline Object 2]
    CL --> CLN[Lifeline Object N]

    CL1 --> L1[lifeline: Energy]
    CL1 --> I1[impact: Power grid failure]
    CL1 --> M1[mitigation: Deploy generators]
```

#### Community Lifelines Reference

```typescript
// Standard FEMA Community Lifelines
const communityLifelines = [
    'Safety and Security',
    'Food, Water, Shelter',
    'Health and Medical',
    'Energy',
    'Communications',
    'Transportation',
    'Hazardous Materials'
];
```

### TeamBriefing Interface

```typescript
interface TeamBriefing {
    missionStatement: string;
    keyObjectives: string[];
    knownRisks: string[];
    commsPlan: string;
}
```

#### ICS Compliance

```mermaid
graph LR
    TB[TeamBriefing] --> ICS[ICS Standards]
    ICS --> ICS201[ICS-201 Format]
    ICS --> ICS202[ICS-202 Objectives]
    ICS --> ICS205[ICS-205 Comms]

    ICS201 --> MS[Mission Statement]
    ICS202 --> KO[Key Objectives]
    ICS205 --> CP[Comms Plan]
```

### TrainingScenario Interface

```typescript
interface TrainingScenario {
    scenarioTitle: string;
    learningObjectives: string[];
    initialBriefing: string;
    timelineInjects: {
        time: string;
        event: string;
        expectedAction: string;
    }[];
}
```

#### Timeline Inject Structure

```mermaid
sequenceDiagram
    participant Facilitator
    participant Participants
    participant System

    Note over System: T+00:00
    Facilitator->>Participants: Initial Briefing

    Note over System: T+15:00
    System->>Facilitator: Inject 1: "Power failure reported"
    Facilitator->>Participants: Present scenario update
    Participants->>Facilitator: "Activate backup generators"

    Note over System: T+30:00
    System->>Facilitator: Inject 2: "Evacuation requested"
    Facilitator->>Participants: Present scenario update
    Participants->>Facilitator: "Implement evacuation plan"
```

### ChatMessage Interface

```typescript
interface ChatMessage {
    sender: 'user' | 'model';
    text: string;
}
```

#### Message Flow

```mermaid
stateDiagram-v2
    [*] --> UserInput: User types message
    UserInput --> UserMessage: Create ChatMessage
    UserMessage --> ChatHistory: Add to messages[]
    ChatHistory --> AIProcessing: Send to Gemini
    AIProcessing --> ModelMessage: Create response
    ModelMessage --> ChatHistory: Add to messages[]
    ChatHistory --> Display: Render in UI
```

## Type Relationships and Dependencies

### Type Dependency Graph

```mermaid
graph TD
    App[App Component] --> View[View Type]
    App --> ID[IncidentDetails]
    App --> AR[AnalysisResult]

    SA[SituationalAwareness] --> ID
    SA --> AR

    OH[OperationsHub] --> AR
    OH --> ID
    OH --> IF[ImpactForecast]
    OH --> TB[TeamBriefing]
    OH --> TS[TrainingScenario]

    PP[PublicPreparedness] --> CM[ChatMessage]
    PP --> Chat[Chat Instance]
```

### Data Flow Between Types

```mermaid
flowchart LR
    subgraph "Input Phase"
        UI[User Input] --> ID[IncidentDetails]
    end

    subgraph "Analysis Phase"
        ID --> AR[AnalysisResult]
    end

    subgraph "Operations Phase"
        ID --> IF[ImpactForecast]
        AR --> TB[TeamBriefing]
        ID --> TS[TrainingScenario]
    end

    subgraph "Chat Phase"
        UserMsg[User Message] --> CM[ChatMessage]
        CM --> Response[AI Response]
        Response --> CM2[ChatMessage]
    end
```

## State Management Patterns

### Global State Types

```typescript
// Application-level state
interface AppState {
    currentView: View;
    incidentDetails: IncidentDetails | null;
    analysisResult: AnalysisResult | null;
}

// View enumeration
type View = 'awareness' | 'preparedness' | 'operations';
```

### Component State Types

```typescript
// SituationalAwareness local state
interface SituationalAwarenessState {
    // Form fields (mirrors IncidentDetails)
    incidentType: string;
    location: string;
    severity: string;
    description: string;

    // UI state
    analysis: AnalysisResult | null;
    isLoading: boolean;
    error: string | null;
}

// PublicPreparedness local state
interface PublicPreparednessState {
    chat: Chat | null;
    messages: ChatMessage[];
    userInput: string;
    isLoading: boolean;
    error: string | null;
}

// OperationsHub local state
interface OperationsHubState {
    forecast: ImpactForecast | null;
    briefing: TeamBriefing | null;
    scenario: TrainingScenario | null;
    isLoading: boolean;
    error: string | null;
}
```

## Data Validation Patterns

### Validation Rules

```typescript
// Validation functions for each type
const validators = {
    incidentDetails: (data: IncidentDetails): ValidationResult => {
        const errors: string[] = [];

        if (!data.location?.trim()) {
            errors.push("Location is required");
        }

        if (!data.description?.trim() || data.description.length < 10) {
            errors.push("Description must be at least 10 characters");
        }

        if (!incidentTypes.includes(data.incidentType)) {
            errors.push("Invalid incident type");
        }

        if (!severityLevels.includes(data.severity)) {
            errors.push("Invalid severity level");
        }

        return {
            isValid: errors.length === 0,
            errors
        };
    }
};

interface ValidationResult {
    isValid: boolean;
    errors: string[];
}
```

### Schema Validation Flow

```mermaid
flowchart TD
    Input[User Input] --> Parse[Parse Data]
    Parse --> Validate[Apply Validators]
    Validate --> Check{Valid?}
    Check -->|Yes| Transform[Type Transform]
    Check -->|No| Errors[Return Errors]
    Transform --> Typed[Typed Data]
    Typed --> Process[Process Request]
    Errors --> Display[Display to User]
```

## Data Transformation Pipeline

### Input to Output Transformation

```mermaid
graph LR
    subgraph "User Input"
        Form[HTML Form] --> Raw[Raw Strings]
    end

    subgraph "Validation"
        Raw --> Clean[Sanitized Data]
        Clean --> Valid[Validated Data]
    end

    subgraph "Type Casting"
        Valid --> Typed[TypeScript Types]
    end

    subgraph "AI Processing"
        Typed --> Prompt[Prompt String]
        Prompt --> AI[AI Model]
        AI --> JSON[JSON Response]
    end

    subgraph "Response Typing"
        JSON --> Parsed[Parsed Object]
        Parsed --> Final[Typed Response]
    end
```

## Type Safety Strategies

### Runtime Type Checking

```typescript
// Type guard functions
function isIncidentDetails(obj: any): obj is IncidentDetails {
    return obj &&
        typeof obj.incidentType === 'string' &&
        typeof obj.location === 'string' &&
        typeof obj.severity === 'string' &&
        typeof obj.description === 'string';
}

function isAnalysisResult(obj: any): obj is AnalysisResult {
    return obj &&
        typeof obj.summary === 'string' &&
        Array.isArray(obj.recommendedActions) &&
        Array.isArray(obj.potentialRisks) &&
        Array.isArray(obj.resourceSuggestions);
}

// Usage example
const processAnalysis = (data: unknown) => {
    if (!isAnalysisResult(data)) {
        throw new Error("Invalid analysis result format");
    }
    // Safe to use as AnalysisResult
    return data;
};
```

### Null Safety Patterns

```typescript
// Safe property access patterns
const safeAccess = {
    getIncidentType: (details: IncidentDetails | null): string => {
        return details?.incidentType ?? 'Unknown';
    },

    getFirstAction: (result: AnalysisResult | null): string | null => {
        return result?.recommendedActions?.[0] ?? null;
    },

    getLifelineCount: (forecast: ImpactForecast | null): number => {
        return forecast?.communityLifelines?.length ?? 0;
    }
};
```

## Data Persistence Considerations

### Future Storage Schema

```mermaid
erDiagram
    Incident ||--o{ Analysis : has
    Incident ||--o{ Forecast : has
    Incident ||--o{ Briefing : has
    Incident ||--o{ Scenario : has
    User ||--o{ Incident : creates
    User ||--o{ ChatSession : has
    ChatSession ||--o{ Message : contains

    Incident {
        uuid id PK
        timestamp created_at
        uuid user_id FK
        json details
        string status
    }

    Analysis {
        uuid id PK
        uuid incident_id FK
        json result
        timestamp generated_at
    }

    ChatSession {
        uuid id PK
        uuid user_id FK
        timestamp started_at
        json messages
    }
```

## Migration and Evolution Strategies

### Version Management

```typescript
// Versioned interfaces for future compatibility
interface IncidentDetailsV1 {
    incidentType: string;
    location: string;
    severity: string;
    description: string;
}

interface IncidentDetailsV2 extends IncidentDetailsV1 {
    coordinates?: [number, number];
    reportedBy?: string;
    verificationStatus?: 'unverified' | 'verified' | 'false';
}

// Migration function
function migrateIncidentDetails(v1: IncidentDetailsV1): IncidentDetailsV2 {
    return {
        ...v1,
        coordinates: undefined,
        reportedBy: undefined,
        verificationStatus: 'unverified'
    };
}
```

## Best Practices

### Type Definition Guidelines

1. **Keep interfaces focused**: Single responsibility per interface
2. **Use strict types**: Avoid `any`, prefer union types
3. **Document complex fields**: Add JSDoc comments
4. **Version interfaces**: Plan for evolution
5. **Validate at boundaries**: Input/output validation

### Naming Conventions

```typescript
// Interface naming
interface [Feature][DataType] {
    // PascalCase for interfaces
}

// Type naming
type [Feature][Type] = // PascalCase for types

// Enum naming
enum [Feature][Enum] {
    // PascalCase for enums
    CONSTANT_CASE // for values
}

// Property naming
interface Example {
    camelCaseProperty: string;
    isBoolean: boolean;  // prefix with 'is' or 'has'
    handleAction: () => void; // prefix with 'handle' for handlers
}
```

---

This comprehensive data model documentation ensures type safety, maintainability, and clear understanding of data structures throughout the Aegis system.